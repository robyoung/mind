"""Add User model

Revision ID: 005
Revises: 004
Create Date: 2017-10-25 18:03:29.216516

"""
import datetime
import os
import uuid

from alembic import op
import sqlalchemy as sa
from sqlalchemy.dialects import postgresql

from mind.utils import hash_email


# revision identifiers, used by Alembic.
revision = '005'
down_revision = '004'
branch_labels = None
depends_on = None

user_helper = sa.Table(
    'user',
    sa.MetaData(),
    sa.Column('uuid', postgresql.UUID(as_uuid=True), primary_key=True),
    sa.Column('created_at', sa.DateTime(), nullable=False),
    sa.Column('email_hash', sa.String(), nullable=False),
)

answer_helper = sa.Table(
    'answer',
    sa.MetaData(),
    sa.Column('id', sa.Integer, primary_key=True),
    sa.Column('email', sa.String),
    sa.Column('user_uuid', postgresql.UUID(as_uuid=True)),
)


def get_or_create(connection, email_hash):
    query = sa.select([user_helper.c.uuid]) \
              .where(user_helper.c.email_hash == email_hash)
    user = connection.execute(query).first()
    if user is not None:
        return user[0]
    else:
        result = connection.execute(user_helper.insert(), [{
            'uuid': uuid.uuid4(),
            'created_at': datetime.datetime.now(),
            'email_hash': email_hash,
        }])
        return result.inserted_primary_key[0]


def upgrade():
    # Create user table
    op.create_table(
        'user',
        sa.Column('uuid', postgresql.UUID(as_uuid=True), nullable=False),
        sa.Column('created_at', sa.DateTime(), nullable=False),
        sa.Column('email_hash', sa.String(), nullable=False),
        sa.Column('twitter_handle', sa.String(), nullable=True),
        sa.PrimaryKeyConstraint('uuid')
    )
    op.create_index(
        op.f('ix_user_email_hash'), 'user', ['email_hash'], unique=True)
    op.add_column(
        'answer',
        sa.Column('user_uuid', postgresql.UUID(as_uuid=True), nullable=True))
    op.create_foreign_key(
        'answer_user_uuid_fkey',
        'answer', 'user', ['user_uuid'], ['uuid'])

    # Migrate emails
    connection = op.get_bind()
    email_cond = answer_helper.c.email != None  # noqa
    emails = sa.select([answer_helper.c.email]) \
               .where(email_cond) \
               .distinct()
    for (email,) in connection.execute(emails):
        email_hash = hash_email(email, os.environ['EMAIL_HASH_SALT'])
        user_uuid = get_or_create(connection, email_hash)
        update_answers = answer_helper \
            .update() \
            .where(answer_helper.c.email == email) \
            .values(user_uuid=user_uuid)
        connection.execute(update_answers)

    # Drop original email field and make answer uuid required
    op.drop_column('answer', 'email')
    op.alter_column(
        'answer', 'user_uuid',
        existing_type=postgresql.UUID(),
        nullable=False)


def downgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_constraint('answer_user_uuid_fkey', 'answer')
    op.drop_column('answer', 'user_uuid')
    op.add_column(
        'answer',
        sa.Column('email', sa.String, nullable=True))
    op.drop_index(op.f('ix_user_email_hash'), table_name='user')
    op.drop_table('user')
    # ### end Alembic commands ###
